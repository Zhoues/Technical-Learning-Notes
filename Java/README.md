# Java学习笔记

[TOC]



## IDEA项目创建

- 步骤多，但是逻辑清晰，**IDEA项目结构如：项目—模块—软件包—类**

1. 首先点击`IDEA`之后，选择**创建新项目**。但是要注意，如果选择的是**创建空项目**之后，会提示**是否加入新模块**，再新模块中，首先先**选择项目的`SDK`**，其实就是`JDK`，选择完毕之后，框架之类的都不用选，一直下一步，直至创建完毕。**如果是直接选择`Java`模块，就是省去创建空项目的那一个步骤**
2. 之后在**项目目录`src`文件夹中，右键添加软件包**，一般命名`com.***`，**之后在软件包的下面右键添加新的`Java`类**，此时该`Java`类就是我一般书写的`Java`文件。



## 快捷键



### 快速生成语句

1. `pvsm`——`public static void main(String[] args){}`
2. `sout`——`System.out.println()`



### 内容辅助键

1. `Ctrl+Alt+space`——内容提示+代码补全



### 快捷键

1. `Ctrl+\`——单行注释
2. `Ctrl+Shift+\`——多行注释
3. `Ctrl+Alt+L`——格式化代码
4. `Ctrl+Alt+V`——生成 调用方法返回值 对应的变量名
5. `Alt + Insert`——**快速生成接口方法**



## 类型转换

- 小数默认类型是`double`，如果需要改成`float`，需要在小数后面加`f`，如`float a = 1.2f`
- 整数默认类型是`int`，如果需要改成`long`，需要在整数后面加`L`，如`long a = 100L`



## 运算符

- 对于数字的+操作是算术运算，但是注意，一个算术运算会把**算式中所有的变量都提升至当前算式的最高类型，且最后返回的结果也为该最高类型**
- 对于字符串的+操作是拼接操作
- 在+操作中，如果出现了字符串，就是连接运算符，否则就是算数运算符。**当连续进行+操作的时候，从左到右依次执行**

```java
System.out.println(1 + 99+" I Love you");
>>> 100 I Love you
System.out.println("I Love you " + 1 + 99);
>>>I Love you 199
```



## 数组

### 数组定义格式

- 格式一： 数据类型 []      变量名
- 范例：     **int []   arr**
- 定义了一个int类型的数组，数组名是arr



- 格式二： 数据类型     变量名 [] 
- 范例：     **int   arr []**
- 定义了一个int类型的变量，变量名是arr数组



### 数组初始化

#### 动态初始化

动态初始化：初始化时只**指定数组长度**，由系统为数组分配初始值

- 格式： 数据类型 [ ]  变量名 = **new** 数据类型[**数组长度**];
- 范例： int []  arr = **new** int[3];

#### 静态初始化

静态初始化 : 初始化时**指定每个数组元素的初始值**，由系统决定数组长度

- 完整格式： 数据类型[] 数组名 = new 数据类型[]{数据1,数据2,数据3...};
- 范例：int[] arr = **new** int[]{s1,s2,s3};



- 简化格式： 数据类型[] 数组名 = {数据1,数据2,数据3...};
- 范例：int[] arr = {s1,s2,s3};



### 数组属性

`arr.length`表示数组申请空间的个数



## **方法**

- 方法是将具有独立功能的代码块组织成为一个整体，使其具有**特殊功能的代码集**



### 方法的定义和调用

- 定义和调用的格式：

```java
//定义
public static 返回值类型 方法名(数据类型 变量名){
	//数据类型和方法名都不能缺少，多个参数之间用逗号分隔
    方法体;
    return 返回值;
}

//调用
方法名(变量名);
```

### 方法的注意事项

- 方法不可以嵌套定义
- `void`表示无返回值，可以省略return，也可以单独书写return，后面不加数据



### 方法重载

​	方法重载指**同一个类中定义的多个方法**之间的关系，满足下列条件的 福哦个方法互相构成重载：

- 重载仅对应**方法的定义**，与方法的调用无关，调用方法参照标准格式
- 重载仅针对**同一个类**中**方法的名称与参数（参数的数据类型或者参数的个数）**进行识别，**与返回值无关**，或者说**不能通过返回值来判定同一个类两个方法是否互相构成重载**



## **类和对象**

- **类是Java程序的基本组成单位**
- 类是对现实生活中一类具有**共同属性和行为**的事物的抽象



类的特点：

- 类是对象的**数据类型**
- 类是具有相同属性和行为的一组对象的集合



对象的属性和行为：

- 属性：类中**方法之外的成员变量**
- 行为：类中**成员方法**（**和前面的方法相比去掉static关键字即可**）



## **封装**

### private关键字

- 是一个**权限修饰符**
- 可以**修饰成员（成员变量和成员方法）**
- 作用是保护成员不被别的类使用，被`private`修饰的成员**只能在本类中才能访问**



针对`private`修饰的**成员变量，如果需要被其他类使用**，提供相应的操作：

- **提供`get变量名()`方法，用于获取成员变量的值，方法用`public`修饰**
- **提供`set变量名()`方法，用于设置成员变量的值，方法用`public`修饰**



### this关键字

- `this`修饰的变量用于指代成员变量
  - 方法的形参如果和成员变量**同名**，**不带`this`修饰的变量指的是形参，而不是成员变量**
  - 方法形参如果**没有**与成员变量**同名**，**不带`this`修饰的变量指的是成员变量**



## **继承**

继承的格式：

```java
public class 子类名 extends 父类名{
    
}
```

继承的好处：

- 提高了代码的**复用性**（多个类相同的成员可以放在同一个列中）
- 提高了代码的**维护性**（如果方法的代码需要修改，修改一处即可）

继承的弊端：

- 类与类之间产生了关系，耦合性增强

### 继承中变量的访问特点

在子类方法中访问一个变量（优先级排序）

- 子类局部范围找（子类方法里面定义的局部变量）
- 子类成员范围找**（可以用`this`指定访问）**
- 父类成员范围找**（可以用`super`指定访问）**
- 如果没有就报错（不考虑父亲的父亲...）



| 关键字 | 访问成员变量   | 访问构造方法 | 访问成员方法     |
| ------ | -------------- | ------------ | ---------------- |
| this   | this.成员变量  | this(...)    | this.成员方法()  |
| super  | super.成员变量 | super(...)   | super.成员方法() |



### 继承中构造方法的访问特点

子类中所有构造方法默认都回访问父类中无参的构造方法



为什么？

- 因为子类回继承父类中的数据，可能还会使用父类的数据，所以子类初始化之前，一定要先完成父类数据的初始化
- **每一个子类构造方法的第一条语句默认都是：super()**



如果父类中没有无参构造方法，只有带参构造方法，该怎么办？

- 通过使用super关键字去显示的调用父类的带参构造方法
- **在父类中自己提供一个无参构造方法（推荐后者）**



### 继承中成员方法的访问特点

通过子类对象访问一个方法

- 子类成员范围找
- 父类成员范围找**（可以用`super`指定访问）**
- 如果都没有就报错（不考虑父亲的父亲）

### 方法重写及其注意事项

子类中出现了和父类中一模一样的方法声明

`@Override`

- 是一个注解
- 可以帮助我们检查重写方法的方法声明的正确性



注意事项：

1. 私有方法不能被重写（父类私有成员子类是不能继承的）
2. 子类方法的权限不能更低（public > 默认 > 私有）
3. Java值类只支持单继承，不支持多继承，支持多层继承

### 权限修饰符

| 修饰符    | 同一个类中 | 同一个包中子类无关类 | 不同包的子类 | 不同包的无关类 |
| --------- | ---------- | -------------------- | ------------ | -------------- |
| private   | OK         |                      |              |                |
| 默认      | OK         | OK                   |              |                |
| protected | OK         | OK                   | OK           |                |
| public    | OK         | OK                   | OK           | OK             |

### 状态修饰符

#### final

final关键字是最终的意思，可以修饰成员方法，成员变量，类



**final修饰的特点：**

1. 修饰类：表明该类时最终类，**不能被继承**
2. 修饰方法：表示该方法时最终方法，**不能被重写**
3. 修饰变量：表明该变量时常量，**不能再次赋值**



**final修饰局部变量：**

- 变量是基本类型：final修饰指的是基本类型的**数据值**不能发生改变
- 变量是引用类型：final修饰指的是引用类型的**地址值**不发生改变，但是**地址里面的内容时可以发生改变的**

#### static

static关键字时静态的意思，可以修饰成员方法，成员变量



**static修饰的特点：**

- **被类的所有对象共享**：这也是我们判断使用静态关键字的条件
- **可以通过类名调用**： 当然也可以通过对象名调用（**当然推荐使用类名调用，统一修改**）



**static访问特点（静态成员方法只能访问静态成员）：**

1. 非静态成员方法
   - 能访问静态成员变量
   - 能访问非静态成员变量
   - 能访问静态成员方法
   - 能访问非静态的成员方法
2. 静态成员方法
   - 能访问静态成员变量
   - 能访问静态成员方法**（为什么main方法调用的函数都是静态的）**



## **多态**

### 多态的前提和体现

- 有继承/实现关系
- 有方法重写
- **有父类引用指向子类对象（最容易体现出来）**



### 多态成员的访问特点

- **成员变量**：编译看**左边**，执行看**左边**
- **成员方法**：编译看**左边**，执行看**右边**

为什么成员变量和成员方法的访问不一样呢？

- 因为**成员方法有重写**，而成员变量没有



### 多态的好处和弊端

- 多态的好处：提高程序的拓展性
  - 具体体现：定义方法的时候，使用父类型作为参数，将来在使用的时候，使用具体的子类型参与操作
- 多态的弊端：不能使用子类的特有功能



## **接口**



### 接口的特点

- 接口用关键字interface修饰

  - public **interface** 接口名{}

- 类实现接口用implements表示

  - public class 类名 **implements** 接口名{}

- 接口不能实例化

  ​	接口如何实例化？**接口是抽象的内容**，参考多态的方式，通过**类对象实例化**，这叫接口多态

  ​	多态的形式：具体类多态，**抽象类多态，接口多态**

  ​	多态的前提：有无继承或者**实现**关系；有无方法重写；有无父（类/接口）引用指向子（实现/类）对象

- 接口的实现类

  ​	要么重写接口重的所有的抽象方法

  ​	要么是抽象类



### 接口的成员特点

- 成员变量

  ​	只能是常量

  ​	默认修饰符：**public static final**

- 构造方法

  ​	**接口没有构造方法**，因为接口主要是对行为进行抽象的，是没有具体存在

  ​	**一个类如果没有父类，默认继承自Object类**

- 成员方法

  ​	只能是抽象方法

  ​	默认修饰符：public abstract



## 内部类



### 内部类的概述

内部类：就是再一个类中定义一个类。



### 内部类访问特点

- 内部类可以**直接访问外部类的成员，包括私有**
- 外部类要访问内部类的成员，必须**创建对象**



### 成员内部类

- 该内部类定义于某一个类的成员位置

```java
public class Outer{
	public class Inner{
		System.out.println("...");
	}
}
```

- 如果内部类是公有（public）的，可以在测试类中直接创建该内部类
  - 格式：外部类名。内部类名 对象名 =  外部类对象.内部类对象

```java
Outer.Inner oi = new Outer().new Inner();
```

- 如果内部类是私有（private）的，不可以在测试类中直接创建该内部类，但是可以在外部类写一个构造方法，实现内部类的构造

```java
public class Outer{
	private class Inner{
		System.out.println("...");
	}
	public void method(){
        Inner i = new Inner();
    }
}
```



### 局部内部类

- 局部内部类是在方法中定义的类，所以**外界是无法直接使用，需要在方法内部构建对象并且使用**
- 该类可以直接访问外部类的成员，也可以访问方法内的局部变量

### 匿名内部类

- 前提：存在一个类或者接口，这里的类可以是具体类，也可以是抽象类
- 格式：

```java
new 类名或者接口名(){
	重写方法
}
```

- 范例：

```java
new Inter(){
	public void show(){
	
	}
}
```

- 实战操作：

```java
public class Outer{
	public void method()
	{
		new Inter()
		{
			@Override
			public void show(){
				System.out.println("匿名内部类")；
			}
		}.show();
		
		/*或者*/
		
		Inter i = new Inter(){
			@Override
			public void show(){
				System.out.println("匿名内部类")；
			}
		};
		
		i.show();
	}
}
```



## 泛型

- 将类型由原来的具体的类型参数化，然后在使用/调用时传入具体的类型



### 可变参数

- 格式：`修饰符 返回值类型 方法名(数据类型... 变量名)`
- 范例：`public static int sum(int... a){}`

可变参数注意事项：

- 这里的变量其实是**一个数组**
- **方法中如果需要多个参数，可变参数放在后面**



## OI流

### File

`File`：文件和目录路径名的抽象表示

- 文件和目录是可以通过`File`封装成对象的
- 对于`File`而言，其封装的并不是一个真正存在的文件，仅仅是一个路径名。

#### 构造方法

| 方法名                              | 说明                                                         |
| ----------------------------------- | ------------------------------------------------------------ |
| `File(String pathname)`             | 通过将给定的路径名字符串转换为抽象路径名来创建新的`File`实例 |
| `File(String parent, String child)` | 从父路径名字符串和子路径名字符串创建新的`File`实例           |
| `File(File parent, String child)`   | 从父抽象路径名和子路径名字符串创建新的`File`实例             |

#### 创建功能

| 方法名                            | 说明                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| `public boolean  createNewFile()` | 当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件 |
| `public boolean  mkdir()`         | 创建由此抽象路径名命名的目录                                 |
| `public boolean  mkdirs()`        | 创建由此抽象路径命名的目录，包括任何必须但是不存在的父目录   |

#### 判断和获取功能

| 返回值类型 | 方法名              | 说明                                                     |
| ---------- | ------------------- | -------------------------------------------------------- |
| `boolean`  | `isDirectory`       | 测试此抽象路径名表示的`File`是否为目录                   |
| `boolean`  | `isFile`            | 测试此抽象路径名表示的`File`是否为文件                   |
| `boolean`  | `exists`            | 测试此抽象路径名表示的`File`是否存在                     |
| `String`   | `getAbsolutePath()` | 返回此抽象路径名的绝对路径名字符串                       |
| `String`   | `getPath()`         | 将此抽象路径名转换为路径名字符串                         |
| `String`   | `getName()`         | 返回由此抽象路径名表示的文件或目录的名称                 |
| `String[]` | `list()`            | 返回此抽象路径名表示的目录汇总文件和目录的名称字符串数组 |
| `File[]`   | `listFiles()`       | 返回此抽象路径名表示的目录中的文件和目录的`File`对象数组 |

#### 删除功能

| 返回值类型 | 方法名   | 说明                             |
| ---------- | -------- | -------------------------------- |
| `boolean`  | `delete` | 删除此抽象路径名表示的文件或目录 |



### 字节流

字节抽象基类：

- `InputStream`：这个抽象类是表示字节输入流的所有类的超类
- `OutputStream`:这个抽象类是表示字节输出流的所有类的超类
- 子类名特点：子类名称都是以其父类名作为子类名的后缀



使用字节输出流写数据的步骤：

-  创建字节输出流对象（调用系统功能创建了文件，创建字节输出流对象，让字节输出流对象指向文件）
- 调用字节输出流对象的写数据方法
- **释放资源（关闭此文件输出流并释放与此流相关联的任何系统资源）**



#### 字节流写数据 *

##### FileOutputStream

- `FileOutputStream(String name)`：构造方法，创建文件输出流以写入具有指定名称的文件。
-  `FileOutputStream(String name， boolean append)`：构造方法，创建文件输出流以写入具有指定名称的文件。**如果`append`为`True`，则为追加写入**

- `close()`：关闭此文件输出流并释放与此流关联的所有系统资源。 
- `write(int b)`：将指定的字节写入此文件输出流。
- `write(byte[] b)`：将指定字节数组中的 `b.length`字节写入此文件输出流。 
- `write(byte[] b, int off, int len)`：将从偏移量 `off`开始的指定字节数组中的 `len`字节写入此文件输出流。 

- **`byte[] b`数组可以通过`String`的方法`getBytes`获取**



##### 字节流写数据实现换行

不同的操作系统对于换行的要求是不一样的

```java
fos.write('\r\n'.getBytes())
```



##### 字节流写数据加异常处理

- `finally`

```java
try{
	可能出现异常的代码
}catch(异常类名 变量名){
	异常的处理代码
}finally{
	指向所有的清除操作
}
```



#### 字节流读数据 *

##### FileIutputStream

- `FileOutputStream(String name)`：构造方法，创建文件输出流以写入具有指定名称的文件。

- `close()`：关闭此文件输出流并释放与此流关联的所有系统资源。 
- `read(int b)`：将指定的字节写入此文件输出流。
- `read(byte[] b)`：将指定字节数组中的 `b.length`字节写入此文件输出流。 
- `read(byte[] b, int off, int len)`：将从偏移量 `off`开始的指定字节数组中的 `len`字节写入此文件输出流。 

- **`byte[] b`数组可以通过`String`的方法`getBytes`获取**



实例：

```java
/* 创建对象 */
FileInputStream fis = new FileInputStream(String name);
FileOutputStream fos = new FileOutputStream(String name);
/* 读写数据 */
byte[] bys = new byte[1024];
int len;
while ( (len = fis.read(bys) ) != -1)
{
    fos.write(bys,0,len);
}
/* 释放资源 */
fos.close();
fis.close();
```



#### 字节缓冲流 *

构造方法：

- 字节缓冲输出流：`BufferedOutputStream(OutputStream out)`
- 字节缓存输入流：`BufferedIutputStream(IutputStream in)`

 

### 字符流

由于字节流操作中文不是特别方便，所以`Java`就提供字符流

- **字符流 = 字节流 + 编码表**

字符流抽象基类：

- `Reader`：字符输入流的抽象类
- `Writer`：字符输出流的抽象类

字符流中和编码相关的两个类：

- `InputStreamReader`
- `OutputStreamWriter` 



#### 字符串中的编码解码问题

编码：

- `byte[] getBytes()`：使用平台的默认字符集将该`String`编码为一系列字节，将结果存储到新的字节数组中
- `byte[] getBytes(String charsetName)`：使用指定的字符集将该`String`编码为一系列字节，将结果存储到新的字节数组中

解码：

- `String(byte[] bytes)`：通过使用平台的默认字符集解码指定的字符数组来构造新的`String`
- `String(byte[] bytes, String charsetName)`：通过使用指定的默认字符集解码指定的字符数组来构造新的`String`

#### 字符流写数据

- `OutputStreamWriter osw = new OutputStreamWriter( new FileOutputStream( String name) );`
- 注意`osw.write();`之后一定要执行刷新流操作，完成刷新进行写入，即**执行 `osw.flush();`**

几种写数据的方法：

- `write(char[] cbuf)`		写入字符数组
- `write(char[], int off, int len)`       写入字符数组的一部分
- `write(String str)`      写一个字符串
- `write(String str ,int off, int len)`    写一个字符串的一部分



#### 字符流读数据

- `InputStreamReader isr = new InputStreamReader( new FileInputStream( String name) );`

- `read()`		一次读取一个数据

- `read(char[] cbuf)`		一次读一个字符数组数据



#### 字符流改进版 *

```java
FileReader	-----  InputStreamReader
FileWriter	-----  OutputStreamWriter 
```



#### 字符缓冲流 *

构造方法：

- 字符缓冲输出流：`BufferedWriter(FileWriter out)`
- 字符缓存输入流：`BufferedReader(FileReader in)`

特有功能：

`BufferedWriter`:

- `void newLine();`		写一行行分隔符，行分隔符有系统属性决定，一般后面配合`flush()`调用

`BufferedReader`:

- `public String readLine()`:	读一行文字。结果包含的行的内容的字符串，不包括任何终止字符，如果流的结尾已经到达，则为`null`

```java
BufferedReader br = new BufferedReader(new FileReader());
BufferedWriter bw = new BufferedWriter(new FileWriter());
String line;
while((line = br.readLine()) != null){
	bw.write(line);
	bw.newLine();
    bw.flush();
}
```



## 多线程

### 多线程的实现方法

#### 继承Thread类

- 定义一个类MyThread继承Thread类
- 在MyThread类中重写run()方法
- 创建MyThread类的对象
- 启动线程

注意：

为什么要重写run方法？

- 因为run()是用来封装被线程执行的代码

run()和start()的区别

- run():封装线程执行的代码，直接调用，相当于普通的方法的调用
- start():启动线程，然后由JVM调用此线程的run方法



**直接调用对象的run()方法不是启动线程，应该是start()方法**



#### 设置和获取线程的名称

Thread类中设置和获取线程名称的方法：

- **void	setName(String name)：讲次线程的名称更改位参数name**
- **String   getName()：返回此线程的名称**

或者使用带参构造方法命名

```java
// main.java
MyThread my1 = new MyThread("1");
MyThread my2 = new MyThread("2");
```

或者调用静态方法获取当前线程

```java
Thread.currentThread().getName()
```



### 线程调度

线程有两种调度模型：

- 分时调度模型：所有线程轮流使用CPU的使用全，平均分配每个线程占用CPU的时间片
- **抢占式调度模型**：优先让优先级高的线程使用CPU，如果线程的优先级相同，你们会随机选择一个，优先级高的线程获取的CPU时间片相对多一些

Thread类中设置和获取线程优先级的方法：

- **public final int getPriority()：返回此线程的优先级**
- **public final void setPriority(int newPriority)：更改此线程的优先级**



线程默认的优先级是5，线程优先级的范围是1-10

**线程优先级高仅仅表示线程获取CPU时间片的机率高**，但是要在次数比较多，或者多次运行的时候才能看到你想要的效果



### 线程控制

| 方法名                         | 说明                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| static void sleep(long millis) | 时当前正在执行的线程停留（暂停执行）指定的毫秒数             |
| void join()                    | 等待这个线程死亡（先把这个线程执行完毕）                     |
| void setDaemon(boolean on)     | 将此线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出 |



### 线程的生命周期

